#include <Servo.h>
#include <PID_v1.h>

// number of PWM inputs
#define NUM_CHANNELS 2

// PWM output upper bound in microseconds
#define MAX_PWM 2000

// Max allowed difference between the signals generated by each Arduino
#define TOLERANCE 100

// ADC resolution (Arduino Nano: 10-bit = 1024)
#define ADC_RES 1024

// Voltage reference for ADC
const double VREF = 5.0;  // VREF might change depending on power supply

// ACS758 current sensor parameters
const double sens = 20;                            // Sensitivity (mV/A) from datasheet
const double resolution = VREF / ADC_RES * 1000;   // Resolution (mV/step)

// Voltage divider resistor values
const double R1 = 100000.0; // resistance of R1 (100K)
const double R2 = 10000.0;  // resistance of R2 (10K)

// Voltage divider input pin
const uint8_t pinVoltage = PIN_A2;

// ACS758 current sensor input pin
const uint8_t pinCurrent = PIN_A4;

// Check pin output
const uint8_t pinCheck = 13;

// PWM input pins
const uint8_t pinPWMArduino = 10;
const uint8_t pinPWMRX = 11;
const uint8_t PinsPWM[] = {
  pinPWMArduino,
  pinPWMRX
};

// Channel struct
typedef struct structChannels{
  uint8_t   pin;            // Channel pin
  uint8_t   pinStateLast;   // Last state the pin was in (HIGH or LOW)
  uint32_t  tStart;         // Time in microseconds the pin changed to HIGH
  uint32_t  tWidth;         // Width of the pulse in microseconds
} Channels_t;

Channels_t Channels[NUM_CHANNELS] = {0};

// Flag used to check if PWM reached MAX_PWM
int maxFlag = 0;

// Servo object (calculated PWM output for the ESC)
Servo esc;

// PID's variables
double setpoint;        // Desired value of Power
double input;           // Calculated power
double output;          // PID's output that will be used to set the PWM

// Initial PID's Parameters
double kp = 2.0, ki = 5.0, kd = 1.0;

// Creating the PID Object
PID pid(&input, &output, &setpoint, kp, ki, kd, DIRECT);


void setup(){
  // DEBUG
  // Serial.begin(115200);

  esc.attach(9);  // attaches the ESC on pin 9 to the servo object

  // setup check pins
  pinMode(pinCheck, OUTPUT);
  digitalWrite(pinCheck, HIGH);

  // setup channel pins
  for(int i = 0; i < NUM_CHANNELS; i++){
    Channels[i].pin = PinsPWM[i];
    pinMode(Channels[i].pin, INPUT_PULLUP);
    Channels[i].pinStateLast = digitalRead(Channels[i].pin);
    Channels[i].tStart = micros();
  }
  // Define the range of PID's outputs (1000 a 2000)
  pid.SetOutputLimits(1000, 2000);

  // Enables the PID controller 
  pid.SetMode(AUTOMATIC);
}

void loop(){
  // read all PWM channels
  readPWMChannels();

  // PWM signal coming from the other Arduino and from the RX
  uint16_t pwmArduino = Channels[0].tWidth;
  uint16_t pwmRX = Channels[1].tWidth;

  // calculate limited PWM
  // this is where we read voltage and current from the battery
  // and calculate a new PWM so that power (volts * amps)
  // doesn't exceed a specified value
  uint16_t outputPWM;

  // reading of current
  // due to the library this data needs to be a Double
  double current = readCurrent();

  // reading of voltage
  // due to the library this data needs to be a Double
  double voltage = readVoltage();

  // calculation of power: (current * voltage)
  // due to the library this data needs to be a Double
  double power = voltage * current;

  // run the PID calculation
  pid.Compute();

  // PID controller is used to generate a new PWM
  // uses a cast to guarantee 16-bit integer format
  outputPWM = static_cast<uint16_t>(output);

  // check if calculated PWM is close to the PWM calculated by the other arduino
  if(inRange(outputPWM, pwmArduino, TOLERANCE)){
    // PWM is within tolerance, output HIGH on the Check pin
    digitalWrite(pinCheck, HIGH);
  }
  else{
    // PWM is out of range, set check pin to low
    digitalWrite(pinCheck, LOW);
  }

  // send calculated PWM signal to the ESC
  esc.writeMicroseconds(outputPWM); 
}


// Return true if value is close to the reference plus or minus tolerance
bool inRange(uint16_t value, uint16_t reference, uint16_t tolerance){
  return (value <= reference+tolerance && value >= reference-tolerance);
}


// This function will read all PWM channels
// and store the pulse width in microseconds
void readPWMChannels(){
  // Current channel
  static uint8_t channel = 0;

  // Current time in microseconds
  uint32_t timeNow = micros();

  // each pass we check one channel
  // read the state of the input
  uint8_t pinStateNow = digitalRead(Channels[channel].pin);

  // if PWM is above MAX_PWM, set maxFlag and output 900 (throttle cut)
  if((timeNow - Channels[channel].tStart) > MAX_PWM){
    Channels[channel].tWidth = 900;
    maxFlag = 1;
  }

  // if pin state changed (different than last)
  if(maxFlag == 0){
    if(pinStateNow != Channels[channel].pinStateLast){        
      // save as new last
      Channels[channel].pinStateLast = pinStateNow;

      if(pinStateNow == HIGH){            
        // pin changed from low to high; log the current time
        Channels[channel].tStart = timeNow;
      }
      else{
        // pin changed from high to low; current time minus start time is the pulse width
        Channels[channel].tWidth = timeNow - Channels[channel].tStart;

        // DEBUG PRINT
        // print channel PWM width
        // if(channel == 0 && millis()%500 < 20){
        //   Serial.print("\tCH:");     
        //   Serial.print(channel+1);
        //   Serial.print(" ");
        //   Serial.println(Channels[channel].tWidth);
        // }
      }
    }
  }
  // else?
  if(pinStateNow == LOW){
    Channels[channel].pinStateLast = LOW;
    Channels[channel].tStart = timeNow;
    maxFlag = 0;
  }

  // go to next channel
  if(++channel >= NUM_CHANNELS)
    channel = 0;
}


// This function will read the current sensor and return its value
double readCurrent(){
  // PLACEHOLDER
  double current;

  // read current sensor
  double adcValue = analogRead(pinCurrent);

  adcValue = resolution * adcValue;
  current = adcValue / sens;
  // current = (adcValue - offset) / sens;

  return current;
}


// This function will read the voltage sensor and return its value
double readVoltage(){
  // PLACEHOLDER
  double voltage;

  // read voltage sensor
  double value = analogRead(pinVoltage);
  value = (value * VREF) / 1024.0; // VREF might change depending on power supply
  voltage = value / (R2/(R1+R2));

  return voltage;
}